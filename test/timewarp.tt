let next : (A : U<0>) -> A -> << `[0(1)] | A >> @ S =
    fun A -> fun x -> mod `[0(1)] x

let id : (A : U<0>) -> A -> A @ S = fun A -> fun x -> x

let next2 : (A : U<0>)
            -> << `[(0 2)] | << `[(0 1)] | A >> >>
            -> << `[(0 1)] | A >> @ S =
  fun A -> fun x ->
    letmod `[(1)] (fun z -> << `[(0 1)] | A >>) mod `[(0 2)] (x2) <- x in
    letmod `[(1)] (fun z -> << `[(0 1)] | A >>) mod `[(0 1)] (x3) <- x2 in
    mod `[(0 1)] x3

axiom lob : (A : U<0>) -> ({`[0(1)] | A} -> A) -> A @ S
axiom lobU : ({`[0(1)] | U<0>} -> U<0>) -> U<0> @ S

let gstream : (A : U<0>) -> U<0> @ S =
    fun A -> lobU (fun s ->  A * << `[0(1)] | s >>)

;let next1 : U<0> -> << `[] | U<0> >> @ T =
;    fun x -> mod l x
;
;let coe : (A : U<0>) -> A -> << l | A >> @ T =
;    fun A x -> mod l x
;
;;; -------------------- AXIOMS for Guarded Rec -------------
;
;axiom lob : (A : U<0>) -> ({l | A} -> A) -> A @ T
;axiom lob1 : ({l | U<0>} -> U<0>) -> U<0> @ T
;axiom lob_beta :
;  (A : U<0>) ->
;  (f : {l | A} -> A) ->
;  Id A (lob A f) (letmod idm (fun z -> A) mod l (x) <- next A (lob A f) in f {l, x})
;  @ T
;axiom lob1_beta :
;  (f : {l | U<0>} -> U<0>) ->
;  Id U<0> (lob1 f) (letmod idm (fun z -> U<0>) mod l (x) <- next1 (lob1 f) in f {l, x})
;  @ T
;
;;; -------------- Guarded Streams -----------------------
;
;let gstream : (A : U<0>) -> U<0> @ T =
;    fun A -> lob1 (fun s ->  A * << l | s >>)
;
;let gstream_fun : (A : U<0>) -> {l | U<0>} -> U<0> @ T =
;   fun A s ->  A * << l | s >>
;
;let unfold : (A : U<0>) -> (gstream A) ->
;    (letmod idm (fun z -> U<0>) mod l (x) <- next1 (gstream A) in
;     (gstream_fun A) {l, x}) @ T =
;    fun A str ->
;        transport1
;            (gstream A)
;            (letmod idm (fun z -> U<0>) mod l (x) <- next1 (gstream A)
;             in (gstream_fun A) {l, x})
;            (lob1_beta (gstream_fun A))
;            str
;
;;; ------- Unfold a bit more readible, but it is the same definition -------
;
;let alt_unfold : (A : U<0>) -> (gstream A) -> A * << l | gstream A >>
;     @ T =
;    fun A str ->
;        transport1
;            (gstream A)
;            (A * << l | gstream A >>)
;            (lob1_beta (gstream_fun A))
;            str
;
;let fold : (A : U<0>) ->
;    (letmod idm (fun z -> U<0>) mod l (x) <- next1 (gstream A)
;     in (gstream_fun A) {l, x})
;    -> gstream A @ T =
;    fun A str ->
;        transport1
;            (letmod idm (fun z -> U<0>) mod l (x) <- next1 (gstream A) in (gstream_fun A) {l, x})
;            (gstream A)
;            (inv_eq1
;                (gstream A)
;                (letmod idm (fun z -> U<0>) mod l (x) <- next1 (gstream A) in (gstream_fun A) {l, x})
;                (lob1_beta (gstream_fun A)))
;            str
;
;;; -------------
;
;let ghead : (A : U<0>) -> (gstream A) -> A @ T =
;    fun A lst -> fst (unfold A lst)
;
;let gcons : (A : U<0>) -> A -> (gstream A) -> gstream A @ T =
;    fun A head tail -> fold A (pair (head , next (gstream A) tail))
;
;;; ----------------------------- Streams --------------------------
;
;let stream : (A : U<0>) -> U<0> @ S =
;    fun A -> << g | gstream <<d | A>> >>
